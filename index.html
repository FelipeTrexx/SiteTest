<!--
	Sp4ce Games Viewer
	Based on Babylon Spherical Viewer by Vander R. N. Dias, 2018
-->

<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>Sp4ce Viewer</title>
		<meta name="viewport" content="width=device-width, user-scalable=no">
		<!-- Babylon.js -->
		<script src="https://cdn.jsdelivr.net/npm/webxr-polyfill@latest/build/webxr-polyfill.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
		<script src="https://assets.babylonjs.com/generated/Assets.js"></script>
		<script src="https://preview.babylonjs.com/ammo.js"></script>
		<script src="https://preview.babylonjs.com/cannon.js"></script>
		<script src="https://preview.babylonjs.com/Oimo.js"></script>
		<script src="https://preview.babylonjs.com/earcut.min.js"></script>
		<script src="https://preview.babylonjs.com/babylon.js"></script>
		<script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
		<script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
		<script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
		<script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
		<script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
		<script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
		<script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
		

		<style>
			html, body
			{
				overflow: hidden;
				width: 100%;
				height: 100%;
				margin: 0;
				padding: 0;
				color:#C0C0C0;
				font-family: arial;
				font-size: 2vh;
				-webkit-touch-callout: none; /* iOS Safari */
				-webkit-user-select: none; /* Safari */
				-khtml-user-select: none; /* Konqueror HTML */
				-moz-user-select: none; /* Firefox */
				-ms-user-select: none; /* Internet Explorer/Edge */
				user-select: none; /* Non-prefixed version, currently supported by Chrome and Opera */
			}
			
			h1 { font-size: 8vh; color: #FFFF00; }
			h2 { font-size: 4vh; color: #FFFF00; }

			#renderCanvas
			{
				width: 100%;
				height: 100%;
				touch-action: none;
			}

			<link rel="icon" href="http://sp4ce.com.br/wp-content/uploads/2021/06/cropped-cropped-favicon-32x32.png" sizes="32x32" />
			<link rel="icon" href="http://sp4ce.com.br/wp-content/uploads/2021/06/cropped-cropped-favicon-192x192.png" sizes="192x192" />
			<link rel="apple-touch-icon" href="http://sp4ce.com.br/wp-content/uploads/2021/06/cropped-cropped-favicon-180x180.png" />
		</style>
	</head>
<body>
	<canvas id="renderCanvas" style="visibility:hidden"></canvas>
	<div id="frontdiv" style="background:#000000; position:absolute; top:0; left:0; width:100%; height:100%; cursor:pointer" onclick="StartAmbience()">
		<table border=0 width=100% height=100% cellspacing=0 cellpadding=0>
		<tr><td width=100% valign=middle>
		<center>
			<img src="tex/1_sp4ce.png"><br><br>
			<img src="tex/2_welcome.png"><br><br>
			<img src="tex/3_clickdrag.png"><br><br>
			<img src="tex/separator.png"><br><br>
			<img src="tex/4_look.png"><br><br>
			<img src="tex/separator.png"><br><br>
			<img src="tex/5_vrbtn.png"><br><br>
			<img src="tex/6_startbtn.png"><br>
		</center>
		</td></tr>
		</table>
	</div>

	<script>
		var canvas = document.getElementById("renderCanvas");

		function startRenderLoop(engine, canvas)
		{
			engine.runRenderLoop(function()
			{
				if (sceneToRender && sceneToRender.activeCamera)
				{
					sceneToRender.render();
				}
			});
		}

		var engine = null;
		var scene = null;
		var sceneToRender = null;
		var camera = null;

		var cur_dome = 0;
		var domes = [ 'stereo_001.jpg', 'stereo_002.jpg', 'stereo_003.jpg', 'stereo_004.jpg', 'stereo_005.jpg', 'stereo_006.jpg', 'stereo_007.jpg' ];
		var dome = null;
		var next_btn = null;
		var prev_btn = null;
		var music = null;
		var pick_time = 0;
		var frame = 0;
		var loading = null;
		var ltrigger = false;
		var rtrigger = false;
		
		var backs_count = Math.max(window.innerWidth, window.innerHeight) * 0.01;
/*
		for (var i=0; i<backs_count; i++)
		{
			var img = new Image();
			img.src = './tex/back' + Math.ceil(Math.random()*7) + '.png';
			var div = document.createElement('div');
			div.style = 'position:absolute; top:' + Math.ceil(Math.random()*window.innerHeight) + 'px; left:' + Math.ceil(Math.random()*window.innerWidth) + 'px; transform:rotate(' + Math.ceil(Math.random()*360) + 'deg';
			div.appendChild(img);
			document.getElementById('frontdiv').appendChild(div);
		}
*/

		// try to keep screen on
		let wakeLock = null;
		try
		{
			wakeLock = navigator.wakeLock.request('screen');
		}
		catch (err)
		{
		}

		function createDefaultEngine()
		{
			return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false});
		};

		function createScene()
		{
			var scene = new BABYLON.Scene(engine);
			camera = new BABYLON.ArcRotateCamera("Camera", -Math.PI / 2,  Math.PI / 2, 5, BABYLON.Vector3.Zero(), scene);
			camera.attachControl(canvas, true);
			camera.inputs.attached.mousewheel.detachControl(canvas);

			dome = new BABYLON.PhotoDome(
				"sp4ce",
				"./tex/scenes/" + domes[cur_dome],
				{
					resolution: 32,
					size: 1000
				},
				scene
			);

			dome.imageMode = BABYLON.PhotoDome.MODE_TOPBOTTOM;

			next_btn = BABYLON.MeshBuilder.CreatePlane("next_btn", {height:0.75, width:1.5});
			next_btn.position.x = 1;
			next_btn.position.y = -3;
			next_btn.position.z = 1;
			next_btn.rotation.x = 45;
			var next_mat = new BABYLON.StandardMaterial("next", scene);
			next_mat.diffuseTexture = new BABYLON.Texture("./tex/btn_next.png", scene);
			next_mat.opacityTexture = next_mat.diffuseTexture;
			next_btn.material = next_mat;
			next_btn.actionManager = new BABYLON.ActionManager(scene);
			next_btn.actionManager.registerAction(new BABYLON.ExecuteCodeAction(
				BABYLON.ActionManager.OnPickTrigger, 
				function (evt)
				{
					NextDome(1);
				}));

			prev_btn = BABYLON.MeshBuilder.CreatePlane("prev_btn", {height:0.75, width:1.5});
			prev_btn.position.x = -1;
			prev_btn.position.y = -3;
			prev_btn.position.z = 1;
			prev_btn.rotation.x = 45;
			var prev_mat = new BABYLON.StandardMaterial("prev", scene);
			prev_mat.diffuseTexture = new BABYLON.Texture("./tex/btn_prev.png", scene);
			prev_mat.opacityTexture = prev_mat.diffuseTexture;
			prev_btn.material = prev_mat;
			prev_btn.actionManager = new BABYLON.ActionManager(scene);
			prev_btn.actionManager.registerAction(new BABYLON.ExecuteCodeAction(
				BABYLON.ActionManager.OnPickTrigger, 
				function (evt)
				{
					NextDome(-1);
				}));
				
			loading = BABYLON.MeshBuilder.CreatePlane("loading", {height:1, width:1});
			loading.position.x = 0;
			loading.position.y = -2;
			loading.position.z = 1;
			loading.rotation.x = 45;
			var loading_mat = new BABYLON.StandardMaterial("loading", scene);
			loading_mat.diffuseTexture = new BABYLON.Texture("./tex/loading.png", scene);
			loading_mat.opacityTexture = loading_mat.diffuseTexture;
			loading.material = loading_mat;
			loading_mat.diffuseTexture.onLoadObservable.addOnce(function()
			{
				loading.setEnabled(false);
			});


			scene.registerBeforeRender(function()
			{
				var ray = scene.activeCamera.getForwardRay();
				var hit = scene.pickWithRay(ray);
				if (hit.pickedMesh && (hit.pickedMesh == next_btn || hit.pickedMesh == prev_btn))
				{
					pick_time += scene.getEngine().getDeltaTime() * 0.001;
					if (pick_time >= 2)
					{
						if (hit.pickedMesh == next_btn) NextDome(1);
						else if (hit.pickedMesh == prev_btn) NextDome(-1);

						pick_time = 0;
					}

					var scale = 1 + pick_time*0.3;
					hit.pickedMesh.scaling.x = hit.pickedMesh.scaling.y = scale;
				}
				else
				{
					pick_time = 0;
					next_btn.scaling.x = next_btn.scaling.y = prev_btn.scaling.x = prev_btn.scaling.y = 1;
				}
				
				if (loading.isEnabled())
				{
					loading.rotation.z -= 0.05;
					if (loading.rotation.z < 6.28) loading.rotation.z += 6.28;
				}
			});

			var light = new BABYLON.HemisphericLight("hemiLight", new BABYLON.Vector3(-1, 1, 0), scene);
			light.diffuse = new BABYLON.Color3(1, 1, 0.8);
			light.specular = new BABYLON.Color3(1, 1, 1);
			light.groundColor = new BABYLON.Color3(1, 1, 1);

			return scene;
		};

		window.initFunction = async function()
		{
			var asyncEngineCreation = async function()
			{
				try
				{
					return createDefaultEngine();
				}
				catch(e)
				{
					console.log("the available createEngine function failed. Creating the default engine instead");
					return createDefaultEngine();
				}
			}

			window.engine = await asyncEngineCreation();
			if (!engine) throw 'engine should not be null.';
			startRenderLoop(engine, canvas);
			window.scene = createScene();
		};

		initFunction().then(() =>
		{
			sceneToRender = scene;
		});

		// Resize
		window.addEventListener("resize", function()
		{
			engine.resize();
		});

		function StartAmbience()
		{
			music = new BABYLON.Sound("ambience", "./snd/ambience_001.mp3", scene, null, { loop: true, autoplay: true, volume: 1 });
			document.getElementById("frontdiv").style.visibility = "hidden";
			document.getElementById("renderCanvas").style.visibility = "visible";
			scene.createDefaultXRExperienceAsync({}).then((xrHelper) =>
			{
				xrHelper.input.onControllerAddedObservable.add((controller) =>
				{
					controller.onMotionControllerInitObservable.add((motionController) =>
					{
						if (motionController.handness === 'left')
						{
							const xr_ids = motionController.getComponentIds();
							let trigger = motionController.getComponent(xr_ids[0]);
							let abuttonComponent = motionController.getComponent(xr_ids[1]);

							trigger.onButtonStateChangedObservable.add(() =>
							{
								if (trigger.pressed)
								{
									if (!ltrigger)
									{
										ltrigger = true;
										NextDome(1);
									}
								}
								else ltrigger = false;
							});
						}

						if (motionController.handness === 'right')
						{
							const xr_ids = motionController.getComponentIds();
							let trigger = motionController.getComponent(xr_ids[0]);
							let abuttonComponent = motionController.getComponent(xr_ids[1]);

							trigger.onButtonStateChangedObservable.add(() =>
							{
								if (trigger.pressed)
								{
									if (!rtrigger)
									{
										rtrigger = true;
										NextDome(-1);
									}
								}
								else rtrigger = false;
							});
						}
					});
				});
			}, (error) => {});
		}

		function NextDome(add)
		{
			cur_dome += add;
			if (cur_dome >= domes.length) cur_dome = 0;
			else if (cur_dome < 0) cur_dome = domes.length-1;

			loading.setEnabled(true);
			next_btn.setEnabled(false);
			prev_btn.setEnabled(false);

			var tex = new BABYLON.Texture("./tex/scenes/" + domes[cur_dome], scene, false, false);

			tex.onLoadObservable.addOnce(function()
			{
				dome.photoTexture = tex;
				loading.setEnabled(false);
				next_btn.setEnabled(true);
				prev_btn.setEnabled(true);
			});

		}
	</script>
</body>
</html>
